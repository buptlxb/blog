<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>关于妹子（Maze）</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="keywords" content="c,stack,queue" />
<!-- blog ico 
<link type="image/x-icon" rel="icon" href="images/ruchee.ico" />
<link type="image/x-icon" rel="shortcut icon" href="images/ruchee.ico" />
-->
</head>
<body>
<div id="header">
	<ul id="top-nav">
		<li>
			<a href="index.html">首页</a>
		</li>
		<li>
			<a href="tips.html">榆桑拾遗</a>
		</li>
		<li>
			<a href="diary.html">日记</a>
		</li>
	</ul>
</div>

<div id="cse"></div>


<div class="toc">
<ul>
<li><a href="#toc_0.1">关于妹子（Maze）</a>
<ul>
<li><a href="#toc_0.1.1">写在前面</a>
<li><a href="#toc_0.1.2">利用DFS搞定妹子</a>
<li><a href="#toc_0.1.3">利用BFS搞定妹子</a>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_0.1" class="justcenter">关于妹子（Maze）</h2>

<h3 id="toc_0.1.1">写在前面</h3>

<p>
以前也学过关于栈和队列的知识，也知道一些各自的特点和简单的应用场景。对于DFS（深度优先搜索）和BFS（广度优先搜索）也有一点了解。但却不曾想过用在妹子（Maze）身上。
</p>

<hr />

<h3 id="toc_0.1.2">利用DFS搞定妹子</h3>

<pre class="brush:c">

#include &lt;stdio.h&gt;

#define MAX_ROW 5
#define MAX_COL 5

typedef struct point {
	int row;
	int col;
} Point;

void push(Point p);
Point pop(void);
int is_empty(void);
void print_maze(void);
void visit(int, int, Point);

Point stack[512];
int top = 0;
int maze[MAX_ROW][MAX_COL] = {
	0, 1, 0, 0, 0,
	0, 1, 0, 1, 0,
	0, 0, 0, 0, 0,
	0, 1, 1, 1, 0,
	0, 0, 0, 1, 0
};
Point predecessor[MAX_ROW][MAX_COL] = {
	{{-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}},
	{{-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}},
	{{-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}},
	{{-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}},
	{{-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}}
};

int main(void)
{
	Point p = {0, 0};
	maze[p.row][p.col] = 2;
	push(p);

	while (!is_empty()) {
		p = pop();
		if (p.row == MAX_ROW - 1 &amp;&amp; p.col == MAX_COL - 1)
			break;
		if (p.col + 1 &lt; MAX_COL &amp;&amp; maze[p.row][p.col+1] == 0)
			visit(p.row, p.col + 1, p);
		if (p.row + 1&lt; MAX_ROW &amp;&amp; maze[p.row+1][p.col] == 0)
			visit(p.row + 1, p.col, p);
		if (p.col - 1 &gt;= 0 &amp;&amp; maze[p.row][p.col-1] == 0)
			visit(p.row, p.col-1, p);
		if (p.row - 1 &gt;= 0 &amp;&amp; maze[p.row-1][p.col] == 0)
			visit(p.row-1, p.col, p);
		print_maze();
	}
	if (p.row == MAX_ROW - 1 &amp;&amp; p.col == MAX_COL -1) {
		printf("(%d, %d)\n", p.row, p.col);
		while (predecessor[p.row][p.col].row != -1) {
			p = predecessor[p.row][p.col];
			printf("(%d, %d)\n", p.row, p.col);
		}
	} else
		printf("No path!\n");
	return 0;
}

void push(Point p)
{
	stack[top++] = p;
}

Point pop(void)
{
	return stack[--top];
}

int is_empty(void)
{
	return top == 0;
}

void print_maze(void)
{
	int i, j;
	for (i =0; i &lt; MAX_ROW; i++) {
		for (j = 0; j &lt; MAX_COL; j++)
			printf("%d ", maze[i][j]);
		putchar('\n');
	}
	printf("**********\n");
}

void visit(int row, int col, Point pre)
{
	Point visit_point = {row, col};
	maze[row][col] = 2;
	predecessor[row][col] = pre;
	push(visit_point);
}
</pre>

<p>
从中可以清楚地栈的应用，利用这种方法对妹子的探索有时不是最优解。
</p>

<h3 id="toc_0.1.3">利用BFS搞定妹子</h3>
<pre class="brush:c">

#include &lt;stdio.h&gt;

#define MAX_ROW 5
#define MAX_COL 5

typedef struct point {
	int row;
	int col;
} Point;

void push(Point p);
Point pop(void);
int is_empty(void);
void print_maze(void);
void visit(int, int, Point);

Point stack[512];
int top = 0;
int maze[MAX_ROW][MAX_COL] = {
	0, 1, 0, 0, 0,
	0, 1, 0, 1, 0,
	0, 0, 0, 0, 0,
	0, 1, 1, 1, 0,
	0, 0, 0, 1, 0
};

//Point predecessor[MAX_ROW][MAX_COL] = {
//	{{-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}},
//	{{-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}},
//	{{-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}},
//	{{-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}},
//	{{-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}}
//};

int main(void)
{
	Point p = {0, 0};
	maze[p.row][p.col] = 2;
	push(p);

	while (!is_empty()) {
		p = pop();
		push(p);
		if (p.row == MAX_ROW - 1 &amp;&amp; p.col == MAX_COL - 1)
			break;
		if (p.col + 1 &lt; MAX_COL &amp;&amp; maze[p.row][p.col+1] == 0)
			visit(p.row, p.col + 1, p);
		else if (p.row + 1&lt; MAX_ROW &amp;&amp; maze[p.row+1][p.col] == 0)
			visit(p.row + 1, p.col, p);
		else if (p.col - 1 &gt;= 0 &amp;&amp; maze[p.row][p.col-1] == 0)
			visit(p.row, p.col-1, p);
		else if (p.row - 1 &gt;= 0 &amp;&amp; maze[p.row-1][p.col] == 0)
			visit(p.row-1, p.col, p);
		else
			pop();
		print_maze();
	}
	if (p.row == MAX_ROW - 1 &amp;&amp; p.col == MAX_COL -1) {
		while (!is_empty()) {
			p = pop();
			printf("(%d, %d)\n", p.row, p.col);
		}
	} else
		printf("No path!\n");
	return 0;
}

void push(Point p)
{
	stack[top++] = p;
}

Point pop(void)
{
	return stack[--top];
}

int is_empty(void)
{
	return top == 0;
}

void print_maze(void)
{
	int i, j;
	for (i =0; i &lt; MAX_ROW; i++) {
		for (j = 0; j &lt; MAX_COL; j++)
			printf("%d ", maze[i][j]);
		putchar('\n');
	}
	printf("**********\n");
}

void visit(int row, int col, Point pre)
{
	maze[row][col] = 2;
	Point visit_point = {row, col};
	push(visit_point);
}
</pre>

<p>
从上可以看到队列的应用，利用这种方法把妹不是问题。
</p>

<hr />
<p>
<red>date:</red>2013-03-27
<hr />
</p>


<div id="goTopBtn"></div>

<center  style="font-family: 微软雅黑; font-size: small; font-weight: normal; color: #009933">
Ranen&nbsp;&copy;&nbsp;2012-2013&nbsp;www.gotit.sina.com
<br>
Generated by <a href="http://www.vim.org" target="_blank">Vim</a> &amp; <a href="http://code.google.com/p/vimwiki/" target="_blank">Vimwiki</a>
</center>

<script type="text/javascript" src="jquery-1.4.2.min.js"></script>
<script type="text/javascript" src="vimwiki.js"></script>
</body>
</html>
