<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>gcc宏展开</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"> 
<meta name="keywords" content="c,gcc,macro" />
<!-- blog ico 
<link type="image/x-icon" rel="icon" href="images/ruchee.ico" />
<link type="image/x-icon" rel="shortcut icon" href="images/ruchee.ico" />
-->
</head>
<body>
<div id="header">
	<ul id="top-nav">
		<li>
			<a href="index.html">首页</a>
		</li>
		<li>
			<a href="tips.html">榆桑拾遗</a>
		</li>
		<li>
			<a href="diary.html">日记</a>
		</li>
	</ul>
</div>

<div id="cse"></div>


<div class="toc">
<ul>
<li><a href="#toc_0.1">gcc宏展开</a>
<ul>
<li><a href="#toc_0.1.1">写在前面</a>
<li><a href="#toc_0.1.2">什么是宏</a>
<li><a href="#toc_0.1.3">怎么定义一个宏</a>
<li><a href="#toc_0.1.4">宏是怎么展开的</a>
<li><a href="#toc_0.1.5">写在后面</a>
</ul>
</ul>
</ul>
</div>

<h2 id="toc_0.1" class="justcenter">gcc宏展开</h2>

<h3 id="toc_0.1.1">写在前面</h3>
<p>
最近在写一些测试，由于某些原因，用到了大量的宏和内联汇编。自己又不怎么会，所以写几个例子，看看宏展开的过程。
</p>

<hr />

<h3 id="toc_0.1.2">什么是宏</h3>
<p>
宏（Macro），从中文并不好理解，虽然这是一个创意不错的翻译，简单的从英文看，宏就是一些命令，组织在一起。其实c语言中很多东西，都是为了代码重用而创造出来。当然宏并非c语言所独有，这是一个很有用的概念。c语言的宏系统是由<code>c preprocessor</code>来完成的，这也决定了其的生命周期。
</p>

<h3 id="toc_0.1.3">怎么定义一个宏</h3>

<p>
宏定义分为两种：
</p>
<ol>
<li>
变量式宏定义（Object-like Macro）
<pre class="brush:c">
		#define N 20
		#define STR "Hello World!"
</pre>

<li>
函数式宏定义（Function-like Macro）
<pre class="brush:c">
		#define max(a, b) ((a) &gt; (b) ? (a) : (b))
</pre>

</ol>
<h3 id="toc_0.1.4">宏是怎么展开的</h3>
<p>
上两个例子大家自己一看就知道个大概了。
</p>

<p>
程序如下：
</p>
<pre class="brush:c">

#include &lt;stdio.h&gt;

#define MOV mov
#define EQ eq
#define foo(arg1, arg2) { \
	printf("foo:%s\n", #arg1 #arg2); \
	bar(arg1, arg2) \
}

#define bar(a1, a2) {\
	printf("bar:%s\n", #a1 #a2); \
	goo(a1, a2) \
}

#define goo(b1, b2) { \
	printf("goo:%s\n", #b1 #b2); \
}

int main(void)
{
	printf("foo(MOV,EQ) start\n");	
	foo(MOV,EQ)
	printf("foo(MOV,EQ) end\n");	
	printf("bar(MOV,EQ) start\n");	
	bar(MOV,EQ)
	printf("bar(MOV,EQ) end\n");	
	printf("goo(MOV,EQ) start\n");	
	goo(MOV,EQ)
	printf("goo(MOV,EQ) end\n");	

	printf("foo(,EQ) start\n");	
	foo(,EQ)
	printf("foo(,EQ) end\n");	
	printf("bar(,EQ) start\n");	
	bar(,EQ)
	printf("bar(,EQ) end\n");	
	printf("goo(,EQ) start\n");	
	goo(,EQ)

	return 0;
}
</pre>

<p>
利用<code>gcc -E test.c -o test.E</code>可以对源文件只做预处理，不编译。结果如下：
</p>
<pre class="brush:c">
# 2 "test.c" 2
# 19 "test.c"
int main(void)
{
 printf("foo start\n");
 { printf("foo:%s\n", "MOV" "EQ"); { printf("bar:%s\n", "mov" "eq"); { printf("goo:%s\n", "mov" "eq"); } } }
 printf("foo end\n");
 printf("bar start\n");
 { printf("bar:%s\n", "MOV" "EQ"); { printf("goo:%s\n", "mov" "eq"); } }
 printf("bar end\n");
 printf("goo start\n");
 { printf("goo:%s\n", "MOV" "EQ"); }
 printf("goo end\n");
 return 0;
}
</pre>

<p>
第二个例子的源程序：
</p>
<pre class="brush:c">

#include &lt;stdio.h&gt;

#define MOV mov
#define EQ eq
#define foo(arg) { \
	printf("foo:%s\n", #arg); \
	bar(arg) \
}

#define bar(a) {\
	printf("bar:%s\n", #a); \
	goo(a) \
}

#define goo(b) { \
	printf("goo:%s\n", #b); \
}

#define com(x, y) comm(x, y)
#define comm(x, y) x ## y
int main(void)
{
	printf("foo(com(MOV,EQ)) start\n");	
	foo(com(MOV,EQ))
	printf("foo(com(MOV,EQ)) end\n");	
	printf("bar(com(MOV,EQ)) start\n");	
	bar(com(MOV,EQ))
	printf("bar(com(MOV,EQ)) end\n");	
	printf("goo(com(MOV,EQ)) start\n");	
	goo(com(MOV,EQ))
	printf("goo(com(MOV,EQ)) end\n");	

	printf("foo(com(,EQ)) start\n");	
	foo(com(,EQ))
	printf("foo(com(,EQ)) end\n");	
	printf("bar(com(,EQ)) start\n");	
	bar(com(,EQ))
	printf("bar(com(,EQ)) end\n");	
	printf("goo(com(,EQ)) start\n");	
	goo(com(,EQ))
	printf("goo(com(,EQ)) end\n");	
	return 0;
}
</pre>

<p>
使用同样的方法可以看到预处理之后：
</p>
<pre class="brush:c">

# 916 "/usr/include/stdio.h" 3 4

# 2 "com.c" 2
# 21 "com.c"
int main(void)
{
 printf("foo(com(MOV,EQ)) start\n");
 { printf("foo:%s\n", "com(MOV,EQ)"); { printf("bar:%s\n", "moveq"); { printf("goo:%s\n", moveq); } } }
 printf("foo(com(MOV,EQ)) end\n");
 printf("bar(com(MOV,EQ)) start\n");
 { printf("bar:%s\n", "com(MOV,EQ)"); { printf("goo:%s\n", moveq); } }
 printf("bar(com(MOV,EQ)) end\n");
 printf("goo(com(MOV,EQ)) start\n");
 { printf("goo:%s\n", moveq); }
 printf("goo(com(MOV,EQ)) end\n");

 printf("foo(com(,EQ)) start\n");
 { printf("foo:%s\n", "com(,EQ)"); { printf("bar:%s\n", "eq"); { printf("goo:%s\n", eq); } } }
 printf("foo(com(,EQ)) end\n");
 printf("bar(com(,EQ)) start\n");
 { printf("bar:%s\n", "com(,EQ)"); { printf("goo:%s\n", eq); } }
 printf("bar(com(,EQ)) end\n");
 printf("goo(com(,EQ)) start\n");
 { printf("goo:%s\n", eq); }
 printf("goo(com(,EQ)) end\n");
 return 0;
}
</pre>

<p>
如果你能看到这里，并自己分析了宏展开的顺序，你已经可以写一点东西自己尝试一下了，相信你对于<code>#</code>和<code>##</code>的用法也有了最直观的认识。
</p>

<hr />

<h3 id="toc_0.1.5">写在后面</h3>

<p>
有些东西会忘记，但是你已经有了自己从头学起的能力
</p>

<hr />
<p>
<red>date:</red> 2013-03-15
<hr />
</p>


<div id="goTopBtn"></div>

<center  style="font-family: 微软雅黑; font-size: small; font-weight: normal; color: #009933">
Ranen&nbsp;&copy;&nbsp;2012-2013&nbsp;www.gotit.sina.com
<br>
Generated by <a href="http://www.vim.org" target="_blank">Vim</a> &amp; <a href="http://code.google.com/p/vimwiki/" target="_blank">Vimwiki</a>
</center>

<script type="text/javascript" src="jquery-1.4.2.min.js"></script>
<script type="text/javascript" src="vimwiki.js"></script>
</body>
</html>
